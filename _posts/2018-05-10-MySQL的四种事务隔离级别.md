---
layout:     post
title:      MySQL的四种事务隔离级别
subtitle:   
date:       2018-05-10
author:     Yezhiwei
header-img: img/WechatIMG38.jpeg
catalog: true
category: JAVA
tags:
    - MySQL
---

### 事务的基本要素（ACID）

* 原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。
* 一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，不可能A扣了钱，B却没收到，这就是事务的一致性。
* 隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。
* 持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。

### MySQL并发问题

#### 脏读

* 脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。

> 当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。如：用户A向用户B转账100元，对应SQL命令如下
> 
```
update account set money=money+100 where name=’B’;  (此时A通知B)
update account set money=money-100 where name=’A’;
```
> 当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。
> 

#### 不可重复读

* 事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。

> 不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

#### 幻读

* 幻读是事务非独立执行时发生的一种现象。例如事务A对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务B又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务A的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务B中添加的，就好像产生幻觉一样，这就是发生了幻读。

> 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

**总结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。**

### MySQL事务隔离级别

| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 | 
| :---- | :----: | :----: | :----: |
| 读未提交（read-uncommitted） | 是 | 是 | 是 | 
| 不可重复读（read-committed） | 否 | 是 | 是 | 
| 可重复读（repeatable-read） | 否 | 否 | 是 | 
| 串行化（serializable） | 否 | 否 | 否 | 

**在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)**










